/**********************************************************
 * BEWARE: This file is a autogenerated stub!
 *********************************************************/
#include <string.h>
#include <stdlib.h>

#include "include/capi/cef_keyboard_handler_capi.h"

#include "cef/base.h"
#include "util.h"

CEF_CALLBACK int keyboard_handler_on_pre_key_event(struct _cef_keyboard_handler_t *self, struct _cef_browser_t *browser, const struct _cef_key_event_t *event, XEvent *os_event, int *is_keyboard_shortcut)
{
	static const char* const eventNames[] = {"RAWKEYDOWN", "KEYDOWN", "KEYUP", "CHAR"}; 

	DEBUG_PRINT("pre key event: %11s, char %c(%c), modifiers 0x%08X, native keycode %d, system key: %d, edit field %d",
		event->type < LENGTH(eventNames) ? eventNames[event->type] : "UNKNOWN", 
		event->character,
		event->unmodified_character,
		event->modifiers,
		event->native_key_code,
		event->is_system_key,
		event->focus_on_editable_field
	);
	return 0;
}

CEF_CALLBACK int keyboard_handler_on_key_event(struct _cef_keyboard_handler_t *self, struct _cef_browser_t *browser, const struct _cef_key_event_t *event, XEvent *os_event)
{
	static char16 lastKeyup = 0;

	if (event->type == KEYEVENT_KEYUP)
	{
		if (lastKeyup == 'g' && event->character == 'o')
		{
			struct _cef_frame_t* const mainFrame = browser->get_main_frame(browser);

			DEBUG_PRINT("Calling javascript with _cef_frame_t* pointer: %x", mainFrame);

			const char szJS[] = "callFromNative('hello', 'from', 'NATIVE');";
			cef_string_userfree_t js = cef_string_userfree_alloc();
			cef_string_from_ascii(szJS, strlen(szJS), js);

			mainFrame->execute_java_script(mainFrame, js, 0, 0);

			cef_string_userfree_free(js);

			//KAI: this correct?
			RDEC(mainFrame);
		}
		lastKeyup = event->character;
	}	
	return 0;
}

struct _cef_keyboard_handler_t *init_keyboard_handler()
{
	struct _cef_keyboard_handler_t *ret = NULL;
	struct refcount *r = NULL;
	char *cp = NULL;

	DEBUG_ONCE("called");
	if (!(r = calloc(sizeof(struct refcount) + sizeof(struct _cef_keyboard_handler_t), 1))) {
		DEBUG_PRINT("#### out of memory! #####");
		return NULL;
	}

	cp = (char*)r;
	cp += sizeof(struct refcount);
	ret = (struct _cef_keyboard_handler_t*)cp;

	if(!init_base((cef_base_t*)ret, sizeof(struct _cef_keyboard_handler_t))) {
		free(r);
		return NULL;
	}
	ret->base.add_ref((cef_base_t*)ret);

	// callbacks
	ret->on_pre_key_event = &keyboard_handler_on_pre_key_event;
	ret->on_key_event = &keyboard_handler_on_key_event;

	return ret;
}